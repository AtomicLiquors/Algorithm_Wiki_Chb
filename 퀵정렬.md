### 퀵 정렬

퀵 정렬은 매우 빠른 정렬 알고리즘으로, 
특히 최적/최악의 중간에 있는 평균 시나리오에서 효율적이다.

<aside>
💡 다양한 컴퓨터 언어가 퀵 정렬을 내장하고 있다.
그럼에도 퀵 정렬의 동작 방식을 공부하면 재귀를 사용해 알고리즘의 속도를 향상시키는 원리를 배울 수 있다.

</aside>

### 분할

> 퀵 정렬은 분할이라는 개념에 기반하고 있다.
> 

배열을 분할한다는 것은…

배열로부터 임의의 수(이를 ‘피벗’이라 한다)를 가져와,
그보다 작은 수는 모두 피벗의 왼쪽에, 큰 수는 모두 피벗의 오른쪽에 두는 것이다.

 자세한 설명은 책 참조.

퀵 정렬의 경우 그 구현방법이 정말 다양하다.

### 퀵 정렬의 효율성

분할의 단계는 두 단계다.

- 비교 : 각 값과 피벗을 비교한다.
- 교환 : 조건이 맞으면 양쪽 포인터 값을 교환한다.

한번에 값 두개를 교환하므로 최악의 경우일지라도 N/2번 교환한다.
어느 정도 정렬이 되어 있는 평균적인 상황에선 N/4번 정도 교환한다.

한 번 분할할 때의 효율성은 다음과 같다.

→ 평균적으로 N번 비교하고 + N/4번 교환하여 = 총 1.25N단계가 걸린다. 시간복잡도는 O(N).

퀵 정렬은 여러 번 분할이 필요하다. 그것까지 따져 보면,

(중략)

퀵 정렬의 시간 복잡도는 O(N*logN)이다. 

O(n^2)보다 빠르고, O(N)보다는 느리다. 그림 추가바람.
최악의 시나리오에서는 O(N^2)이다.

### 퀵 셀렉트

<aside>
💡 평균적으로 퀵 정렬이 삽입정렬보다 우수하므로 웬만한 언어는 퀵 정렬이 내장돼 있다.
그래서 퀵 정렬을 직접 구현할 일은 잘 없다.
그러나 퀵 셀렉트라는 매우 유사한 알고리즘이 실제로 쓸모가 있다.

</aside>

‘배열 내에서 두 번째로 작은 값을 찾고 싶다’고 했을 때,
퀵 셀렉트를 쓰면…

- 전체 배열을 정렬하지 않고도 찾고자 하는 값을 찾을 수 있다.

퀵 셀렉트는 배열을 분할해서 필요한 반쪽만 취한다. 
(…)
평균 시나리오에서 효율성은 O(N)이 된다. (logN이 아니라?)

현재까지 알려진 가장 빠른 정렬 알고리즘의 속도는 O(NlogN)이다.
퀵 정렬이 가장 유명하나, 병합 정렬처럼 다른 알고리즘도 많다.