[<< 메인으로](https://github.com/AtomicLiquors/Algorithm_Wiki_Chb)

&nbsp;  
&nbsp;  
# 빅 오 표기법

> “원소가 N개일 때, 연산이 몇 단계가 필요할까?”  
> 빅 오 표기법은 상수를 무시한다.  
> 속도 = 성능 = 효율성으로 간주한다.

&nbsp;  
## O(1)
원소 수와 무관하게 일정하다.  
한 단계라는 뜻이 아니며,   
N과 무관한 상수이자 0차식이라는 의미로 받아들이면 되겠다.

&nbsp;  
## O(N)
원소수 N과 비례하는 단계 수가 필요하다.

&nbsp;  
## O(N^2)
원소수 N의 제곱과 비례하는 단계 수가 필요하다.  
N^2단계가 필요하다 :  — 이차 시간이라고도 한다.

- 예시 : 버블 정렬

&nbsp;  
## O(logN)
log 2 N 단계가 필요하다.   
알고리즘에서 대개 로그의 밑을 생략하면 밑은 2라고 간주한다.
    
- 예시 : 이진 탐색



로그logarithm가 지수함수의 역이라는 건 알고 있지만   
그 개념을 명료하게 한마디로 설명할 수 있길 바란다.

log2^8 = 3이다. 8을 얻기 위해서 2라는 수를 3번 곱해야 함을 나타낸다.

뒤집어 말하면,   
**8에서 1이 되기 위해서 2라는 수로 3번 나눠야 함을 나타낸다.**

8을 2로 나눠서 더 이상 나눌 수 없을 때까지 나누려면 3번의 연산을 거쳐야 한다.  
원소 8개를 가진 배열을 이진탐색하여 모든 연산을 수행하려면 최대 3단계가 소요된다.
    
&nbsp;  
### 루프
___
루프 안에 루프가 들어가면(중첩) O(N^2)으로 표기되지만,
그냥 루프를 두 번 돌리는 시간복잡도는 2N이고 O(N)으로 표기된다.

&nbsp;  

### 버블 정렬이  O(N^2)인 이유

---

버블 정렬은 크게 두 가지 단계로 구성되어 있다.

- 비교 : 버블 전체 길이만큼 비교를 수행하고,
- 교환 : 최악의 경우 비교할 때마다 교환을 수행한다.

원소가 N개인 버블 정렬의 비교는 M(n-1) = N^2/2만큼 수행한다. (등차수열의 합 참조)
비교할 때마다 교환하는 최악의 경우에 봉착한다면, 교환은  M(n-1) = N^2/2만큼 수행한다. 

그 합은 N^2이 된다.

(정리하고 보니 실제 단계 수는 N^2이 아니라 그보다 조금 모자란, 근소한 값인데... 
자세히 보니 N^2 - N이다. 내가 뭘 놓친 거지?)

&nbsp;    

## 한계

빅 오 표기법은 자료 수에 대한 차수(N)를 바탕으로 알고리즘의 성능을 나타내는데,
차수가 같은 두 알고리즘의 성능을 비교해 주진 못한다.

예컨대 빅오표기법으로 O(N^2)과 O(N)으로 표기되는 알고리즘은 후자가 더 빠르단 걸 알 수 있지만,
똑같이 O(N)으로 표기되는 두 알고리즘 중 뭐가 더 빠른지는 모른다는 것이다.
효율성이 같아 보이는 두 알고리즘을 구분하는 방법을 소개한다.

— 차수는 내가 갖다붙인 말이니까 통용되는 말로 대체 바람.

필요하면 알고리즘 책 5장 복습.