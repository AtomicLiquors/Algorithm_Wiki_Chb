[<< 메인으로](https://github.com/AtomicLiquors/Algorithm_Wiki_Chb)

&nbsp;  
&nbsp;  

### 읽기

배열의 특정 인덱스에 해당하는 값이 무엇인지 찾는 것이다.

---

컴퓨터의 메모리는 거대한 격자 형태의 셀 집합으로 이해할 수 있다.
그림 첨부 바람.
배열을 선언하면, 컴퓨터는 메모리 격자 내에서 배열 크기만큼 비어있는 셀 그룹을 찾아 할당을 시켜준다.

컴퓨터는 모든 **메모리 주소**에 한 번에 갈 수 있다.
사람이 오른손 새끼손가락을 들어보라고 하면 왼손 엄지부터 일일이 하나씩 들어보지 않아도 
곧바로 새끼손가락을 들 수 있다. 



컴퓨터는 배열의 시작점이 되는 메모리 주소도 기록해 둔다.

그래서... “배열의 n번째 항목을 찾으라!”면 
곧바로 배열의 시작점 + 인덱스에 해당하는 메모리에 바로 접근하여 내용을 읽는다.

&nbsp;  
### 검색

배열에서 특정 값이 어디있는지 찾는 것이다.

---

CS50에서 칠판에 붙인 카드 뒤집기를 했던 걸 기억할 것이다.
배열의 내용은 컴퓨터에게 뒤집어진 카드처럼 보인다.

&nbsp;  
### 삽입

배열에 새 데이터를 집어넣는 것이다.

---

삽입을 할 때는 애초에 할당한 배열 크기보다 커지는데 ,
그걸 해결하는 방식은 언어마다 다르다.

- 배열 끝에 새 데이터를 집어넣는 것은 한 단계면 끝난다.
- 배열 중간에 새 데이터를 집어넣으려면.... 기존의 데이터를 한 자리씩 뒤로 밀어내야 한다.
- 배열 처음에 새 데이터를 집어넣으려면? 기존의 모든 데이터를 밀어내야 한다.
    
    ```java
    ( 데이터 밀어내기() + 삽입() ) = ( 밀어낼 데이터 갯수 + 1 )
    
    따라서 배열의 원소의 갯수롤 N개라고 했을 때, 
    연산 횟수는 최대 (N + 1)번이 된다.
    ```
    

&nbsp;  
### 삭제

---

<aside>
💡 마찬가지로 최대 N+1단계라고 생각했으나, 실은 최대 N단계였다. 왜? 뭘 놓쳤어요.
→ 원소 N개짜리 배열에서 삭제를 하면 남는 원소는 N-1개이기 때문이다.

</aside>

```java
( 삭제() + 데이터 밀어넣기() ) = ( 1 + '삭제하고 남은' 밀어넣을 데이터 갯수 )

<= (1 + ( N - 1) ) = N
```