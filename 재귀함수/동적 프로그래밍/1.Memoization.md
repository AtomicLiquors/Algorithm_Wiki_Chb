[<< 메인으로](https://github.com/AtomicLiquors/Algorithm_Wiki_Chb)

&nbsp;  
&nbsp;  

**메모이제이션 *memoization***
A.K.A. 하향식 / 캐싱Caching

```
💡 동적 프로그래밍을 통한 알고리즘 최적화, 그 첫번째 기법.
```

> 이전에 계산된 결과를 일시적으로 기록하고,  
같은 계산식을 다시 호출하면 기록한 결과를 그대로 가져온다.

“**동적 프로그래밍에서 메모이제이션을 활용하면,  
한 번 계산한 함수 결과를  
<u>해시 테이블</u>에 저장하여,  
재귀 호출을 감소시킬 수 있다..”**


&nbsp;  

## 왜 필요한가?
### "하위 문제 중첩"
메모이제이션은 하위 문제 중첩을 해결하는 데 사용된다.  

동일한 문제를 작게 만들어 해결할 때,  
**더 작은 단위의 문제**를 하위 문제라고 한다.

&nbsp;  

**Q. 피보나치 수열**

```java
def fib(n):
	if n == 0 or n == 1:
		return n
	
	return fib(n-2) + fib(n-1)
	//return문에서 재귀함수 호출이 두 번이나 발생했다.  
	// 이쯤 되면 바로 쎄하다는 걸 눈치채야 한다.
```



시간복잡도는 **O(2^n)**이다.  
자기 자신을 두 번이나 호출하는 함수는 **O(2^n)**이 되기 쉽다.  
 
&nbsp;
 

피보나치 수열의 최적화는 그렇게 간단하지 않다.  
변수에 저장할 데이터가 하나가 아니기 때문이다.   
fib(n-2), fib(n-1) 모두 계산이 되어야 한다.

피보나치 수열의 경우, 그런 **하위 문제**가 **중첩**되어 있는 형태다.

```java
{
	3: 2,
	4: 3,
	5: 5,
	6: 8
}
```

해시 테이블을 이용하면 함수의 매개변수와 리턴값이 키:값 쌍으로 저장이 된다.
이제 함수를 일일이 호출하지 않아도 함숫값을 불러올 수 있다.

그러기 위해서, 각 재귀함수는 두 번째 인자로 해시 테이블을 전달받는다.

```java
def fib(n, memo):
	if n == 0 or n == 1:
		return n
	
	if not memo.get(n): 
		memo[n] = fib(n - 2, memo) + fib(n-1, memo)
		#fib(n)이 계산된 값이 테이블에 없다면, 하나 만들자.

	return memo[n]
```

이제 재귀함수는 2N - 1번 호출되며, 이는 시간복잡도 **O(N)**을 갖는다.

Q. 행, 열 처럼 변수 2 개를 쓰는 경우는 해시 테이블을 어떻게 활용하나요?

A. 키를 행, 열이 들어가는 배열로 만들고, 함숫값을 할당해 줍니다.

 [행, 열] : 함숫값