"힙으로 우선 순위 유지하기"

힙 :   
트리의 일종으로,  
**’우선순위 큐’의 삽입에 발생하는 지연을 해소하기 위해 사용한다.**

1. 힙의 루트 노드는 항상 최소 또는 최댓값이다.
2. 우선순위 큐는 힙의 루트 노드를 입력받는다.

### 우선순위 큐

**“ 앞에서만 데이터에 접근하고 삭제한다. 단 데이터를 삽입할 때마다 정렬시킨다.”**

- 삭제, 접근은 전형적인 큐와 비슷하다. O(1)
- 삽입의 경우 정렬된 배열과 비슷하다. O(N)

*ex) 응급실 : 도착 순서가 아닌 중증도를 기준으로 치료한다.*

### 이진 힙

다음과 같은 조건을 만족하는 이진 트리.

**힙 조건(heap condition)**

- **최대 힙 :** 모든 노드가 자기 자손보다 큰 값을 갖는다.
- **최소 힙 :** 반대로 모든 노드가 자기 자손보다 작은 값을 갖는다.
- 트리는 완전해야 한다. — 트리의 균형을 위함.
    - 빠진 노드 없이 완전히 채워진 트리.
    - 바닥 줄에만 빈 자리를 허용한다.
        
        왼쪽부터 남는 노드를 채우고, 모든 빈 자리는 오른쪽에만.
        

**힙 속성**

- 힙의 정렬은 이진 탐색 트리보다 약하다. 
(이진 탐색 트리는 값을 보고 노드의 왼쪽으로 갈지, 오른쪽으로 갈지 정할 수 있었지.)
- 힙으로는 보통 검색 연산을 구현하지 않는다. 힙으로는 주로 삽입과 삭제를 다룰 뿐이다.
- **루트 노드는 항상 최댓값이다.** → 우선순위 큐를 구현하기에 적합한 특성.
- **마지막 노드**(바닥 레벨 맨 오른쪽 노드)

### 삽입

---

1. 마지막 노드 자리를 탐색한다. 구체적인 방법은 후술.
2. 새 값으로 노드를 만들어서 마지막 노드로 놓는다.
3. 새 노드와 부모 노드를 비교하고, 결과에 따라 서로 위치를 바꾼다.
4. 힙 조건을 충족할 때까지 3을 반복한다.

새 노드를 힙 위/아래로 이동하는 과정을 **트리클링**이라고 한다.

### 삭제

---

힙에서 값을 삭제하려면, **루트 노드만 삭제할 수 있다.**

우선순위 큐처럼.

1. 마지막 노드를 루트 노드 자리로 옮김으로써, 원래 루트 노드를 삭제한다.
2. 새로운 루트 노드를 적절한 자리를 찾을 때까지 트리클링한다.
방법은 다음과 같다.(최대 힙 기준)
    1. 두 자식을 확인해 더 큰 노드를 찾는다.
    (더 작은 노드를 대상으로 위치를 바꾸면 또 힙 조건이 깨지게 돼 있다.)
    2. 트리클링할 노드가 그보다 작다면, 서로 위치를 바꾼다.
    3. 힙 조건이 충족될 때까지 a, b를 반복한다.

힙의 삽입 삭제 연산은 O(logN)이다.
정렬된 배열의 삭제 - O(1)보다는 조금 느리지만, 
정렬된 배열의 삽입 - O(N)보다는 훨씬 빠르다.

**따라서 삽입과 삭제를 매우 빠르게 수행하려면 힙을 사용한다.**

### 마지막 노드 찾기 :

**문제 :**

1. 컴퓨터는 힙을 사람처럼 그림 형태로 보지 못한다.
2. 루트 노드만 보이고, 링크를 따라서만 자식 노드로 갈 수 있다.
3. 마지막 노드를 아무거나 추가할 수는 없다. 
배열의 균형을 유지하여, 연산 속도를 O(logN)으로 유지하고 싶기 때문이다.
    
    → 노드 N개를 모두 순회하지 않고도 마지막 노드를 찾을 수 있을까?
    

**해결 : 배열을 사용해 힙을 구현한다.**

힙 자체가 내부적으로 배열을 사용하는 추상 데이터일 수 있다.

- 루트 노드는 항상 인덱스 0에 저장한다.
- 각 레벨마다 왼쪽부터 오른쪽으로 순서대로 인덱스들을 할당한다.
- 마지막 노드는 항상 배열의 마지막 원소다.
    
    → **이제 마지막 노드를 찾으려면 배열의 마지막 인덱스를 조회하면 된다. → (O(1)**
    

Q. 배열 형태인데 항목 간의 연결 관계는 어떻게 알 수 있나? 트리클링은 어떻게 하나?

A. 
인덱스 n에 해당하는 노드의 왼쪽 자식은 인덱스 **2n + 1**에 있다.
인덱스 n에 해당하는 노드의 오른쪽 자식은 인덱스 **2n + 2**에 있다.

반대로,
인덱스 n에 해당하는 노드의 부모는 인덱스 **int( (n - 1) / 2 )**에 있다.

### 힙 정렬

모든 수를 힙에 집어넣고, 수를 팝해서 배열에 집어넣는 연산을 반복한다.
힙에서 팝할 수 있는 수는 루트 노드뿐이다.
루트 노드는 힙에 있는 수들 중에서 최대 또는 최소 값이다.
그래서 배열에 들어가는 수는 항상 내림차순 또는 오름차순이다.

힙 정렬의 시간복잡도도 O(NlogN)이다.
값 N개를 힙에 삽입해야 하는데, 각 삽입에 logN단계가 걸리기 때문이다.