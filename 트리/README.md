[<< 메인으로](https://github.com/AtomicLiquors/Algorithm_Wiki_Chb)

&nbsp;  

- Binary Tree
- Full Binary Tree
- Complete Binary Tree
- BST (Binary Search Tree)
- Red-Black Tree

&nbsp;  

&nbsp;  
# 트리

<aside>
💡 **순서를 유지하면서도 검색과 삽입, 삭제가 빠른 자료구조는 뭐가 있을까?**

</aside>

- **정렬된 배열**은 삽입과 삭제가 느리다. 매번 배열 항목 전체를 옮겨야 하기 때문이다.
- **해시 테이블**은 순서를 유지하지 못한다. 정렬 프로그램에 적합하지가 않다.
- **퀵 정렬** 같은 정렬 알고리즘은 아무리 빨라도 O(NlogN)이 걸린다.
정렬이 자주 발생할수록 비효율적이다.

<aside>
💡 **백준 1991번 : 문자로 주어지긴 했지만, 숫자를 넣어도 정렬이 가능할 것이다.
교재 코드를 Java로 고쳐보라.**

</aside>

&nbsp;  



트리 역시 노드 기반의 자료구조다.

&nbsp;  
### **관련 개념**

|단어|설명|
|--|---|
| **루트**  |최상위 노드를 말한다.|
|**부모**, **자식**  |한 단계 상위/하위 노드를 가리킨다.|
| **조상**, **자손**  | n단계 상위/하위 노드를 가리킨다.|
| **레벨**  |같은 줄에 해당하는 노드들 / 노드들로 이루어진 한 줄을 말한다.|
| **프로퍼티**| 트리의 균형 상태를 가리킨다.* 

*모든 노드에서 하위 트리 노드 개수가 같다면, 그것을 **균형 트리**라고 한다.


&nbsp;  
## BST : 이진 탐색 트리

---

*binary search tree*

- **이진 트리** 
각 노드가 최대 2개까지 자식을 갖는 트리다.

- **완전 이진 트리**
마지막 레벨은 노드가 왼쪽부터 채워져 있고,
나머지 레벨은 모든 노드가 자식 노드를 2개씩 가진다.

- **이진 탐색 트리**
**다음과 같은 규칙을 갖는 이진 트리다.
    - 각 노드의 자식은 최대 왼쪽에 하나, 오른쪽에 하나다.
    - 한 노드의 왼쪽 자손은 부모보다 작은 값만 가진다.
    - 한 노드의 오른쪽 자손은 부모보다 큰 값만 가진다.
    

트리는 다음에 배울 그래프의 일종이기도 하지만…

- 사이클이 존재할 수 없다.
- 모든 노드가 (간접적으로라도) 서로 연결되어야 한다는 제약이 있다.

&nbsp;  
## 연산

### 검색

---

1. 현재 노드의 값을 확인한다.
2. 찾는 값이 현재 노드보다 작은 값이면 왼쪽, 큰 값이면 오른쪽으로 이동한다.
3. 찾는 값을 발견하거나, 트리의 가장 아래 레벨에 도달하면 종료한다.

**시간 복잡도 :**
$O(logN)$이라고 생각했다면 지금까지 잘 공부한 것이다.
“정렬된 배열”의 “이진 검색”도 $O(logN)$이 걸렸었다.

**+) 노드가 N개면, 레벨은 약 $logN$개다.** 

꽉 채워진 트리에서
레벨이 x개라면 → 전체 노드 수는 등비수열의 합이 된다. 

$[2^0 + 2^1 + 2^2 + …. + 2^{n-1}]$ 

레벨이 1개 추가될 때마다 트리 크기는 약 두 배가 된다.
 → 그래서 노드가 N개면 $log(N)$레벨이 필요하다.

(대충 알겠고 필요하면 명확히 정리합시다.)

&nbsp;  
### 삽입

---

삽입에 있어서는 이진 트리가 정렬된 배열보다 뛰어나다.

적합한 위치를 찾아서 노드의 마지막 레벨까지 도달하게 된다.
마지막 레벨에 도달하기까지 연산 logN번 + 삽입 연산 1번 
= logN + 1 번의 연산
= 시간복잡도 O(logN)

정렬된 배열은 항목들을 밀어내야 하기 때문에 시간복잡도 O(N)

그러므로 이진 탐색 트리가 더 효율적이라는 것을 알 수 있다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/620448f6-6b63-466a-8dce-57735060b1ea/Untitled.png)

데이터를 값 순서대로 삽입하면 정렬된 배열과 다를 바가 없다.
이진 트리의 장점을 십분 활용하려면 균형 상태에 가까워야 한다.
그러기 위해선 데이터 삽입 순서는 무작위로 하는 게 좋다.

### 삭제

---

**이진 탐색 트리에서 가장 어려운 연산.
실제로 너무 헷갈린다. 다음에 한번 더 보자.**

```python
def delete(delValue, node):
	if node is None:
		return None
```

1. 특정 값을 찾는 검색을 수행한다.

```python
	elif delValue < node.value:
		
```

1. 삭제를 수행한다.
- 삭제한 노드의 자식이 없다면 연산은 종료된다.
- 삭제한 노드의 자식이 하나라면, 부모 노드와 자식 노드를 서로 연결해 준다.
- **삭제한 노드의 자식이 둘이라면, 빈 자리를 어떤 노드로 대체할 것인가?**
    - **후속자 노드**(successor node) : 
    삭제된 노드보다 큰 값을 갖는 모든 자식 노드 중, 최솟값을 갖는 자식 노드.
    - **후속자 노드를 어떻게 찾는가?**
        
        “오른쪽 자식을 한 번 방문한 다음, 그 왼쪽 자식을 계속 따라 내려간다.
        
    - **그런데 후속자 노드한테 오른쪽 자식이 딸려 있다면?
    후속자 노드가 빈 자리를 메우러 떠나면 오른쪽 자식은 누구한테 갖다 붙이는가?**
        - 후속자 노드 부모의 왼쪽 자식으로 넣는다.
        - ㅡ**끝!ㅡ**
        
        (그림을 추가할 수 있을까?)
        

삭제의 효율성도 일반적으로 OlogN이다. 

(검색 한 번 + 연결이 끊긴 자식을 처리하는 단계들)

### 이진 탐색 트리 순회

---

모든 노드를 빠짐없이 방문하는 과정을 **순회(traversal)**라고 한다.

ex. 트리의 모든 노드를 **선형으로 정렬하여 출력**한다.

- 트리를 알파벳 오름차순으로 순회할 수 있어야 한다.
    - **중위 순회(inorder traversal)**
        - 중위 순회는 다른 책 찾자.