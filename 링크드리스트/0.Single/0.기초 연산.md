
&nbsp;  
&nbsp;  
# 링크드리스트의 기초 연산
### 읽기

---

일반 배열이었으면 모든 메모리 주소에 한 번에 갈 수 있었겠지만, → O(1)
연결 리스트의 경우 프로그램은 첫 번째 노드의 메모리 주소만 알 수 있다.
나머지 노드가 어딨는지 모른다.

마지막 노드를 읽으려면 시간복잡도는 O(N)이다.

&nbsp;  
&nbsp;  

### 검색 : 값에 해당하는 인덱스 반환

---

검색 속도는 배열과 마찬가지로 O(N)이다.

&nbsp;  
&nbsp;  
### 삽입

---

**연결 리스트의 강점 1.**

배열의 경우 삽입을 하고 나서 그 뒤의 항목을 다 옮겨 줘야 했다. O(N)

연결리스트의 삽입 연산 속도는

- 새 노드를 생성한다.
- 다음 노드를 가리키는 링크를 달아준다.  //최선의 경우. 연산 속도 O(1)
    
    +
    
- 원래 다음 노드를 가리키던 노드는 새로 만든 노드에 연결한다.  
//이것이 리스트 끝에 있다면 최악의 경우. 연산 속도 O(N+1) → O(N)

&nbsp;  
&nbsp;  
### 삭제

---

**연결 리스트의 강점 2.**

**최선**

맨 앞에서 삭제를 할 경우. 시작 위치를 두 번째 노드로 바꾸기만 하면 된다.

**최악**

마지막 노드를 삭제할 경우. 노드 끝까지 링크를 따라간 다음, 끝 노드의 직전 노드를 가져와 링크를 null로 만든다.

링크만 수정하면 데이터가 안 지워지고 남지 않나…?

→ 어떤 언어는 쓰이지 않는 노드를 자동으로 감지해서 “가비지 컬렉트”를 실행한다.